%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACOTES                                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,12pt]{article}

%-----------------------------------------------------------------------------------%
% LAYOUT DA PÁGINA                                                                  %
%-----------------------------------------------------------------------------------%
\usepackage[top=3cm, bottom=3cm, left=2.5cm, right=2.5cm]{geometry}
%\usepackage{fancyhdr} % Permite controlar como são exibidos os cabeçalhos

%-----------------------------------------------------------------------------------%
% FORMATAÇÃO DO TEXTO                                                               %
%-----------------------------------------------------------------------------------%
%\usepackage{setspace} % Permite definir o espaçamento entre linhas

%-----------------------------------------------------------------------------------%
% PACOTES DE IMAGENS                                                                %
%-----------------------------------------------------------------------------------%
\usepackage[pdftex]{graphicx}
%\usepackage[pstarrows]{pict2e} % Amplia as funcionalidades do ambiente picture
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, arrows.meta}

%-----------------------------------------------------------------------------------%
% PACOTES DE TABELAS                                                                %
%-----------------------------------------------------------------------------------%
\usepackage{array} % Facilita a formatação de tabelas
%\usepackage{multirow} % Permite criar células que ocupam várias linhas em uma tabela
\usepackage{longtable} % Permite criar tabelas que quebram de página

%-----------------------------------------------------------------------------------%
% PACOTES MATEMÁTICOS DE BASE                                                       %
%-----------------------------------------------------------------------------------%
\usepackage{amsfonts,amstext,amscd,bezier,amsthm,amssymb}
\usepackage[centertags]{amsmath}

%-----------------------------------------------------------------------------------%
% PACOTES DE SÍMBOLOS MATEMÁTICOS                                                   %
%-----------------------------------------------------------------------------------%
%\usepackage{mathtools} % Símbolos matemáticos extras. (ex.: \xrightharpoon)
%\usepackage[integrals]{wasysym} % Muda o estilo das integrais, além de outros
%                                 símbolos extras
%\usepackage[nice]{nicefrac} % Permite o uso de frações "melhores". Usar \nicefrac{}{}

%-----------------------------------------------------------------------------------%
% PACOTES DE FONTES MATEMÁTICAS                                                     %
%-----------------------------------------------------------------------------------%
%\usepackage{mathbbol} % Quase todos os símbolos com \mathbb
%\usepackage{bbm} % Extensão dos símbolos de \mathbb. Usar comando \mathbbm
%\usepackage{calrsfs} % Muda o estilo de \mathcal
%\usepackage[mathcal]{euscript} % Muda o estilo de \mathcal

%-----------------------------------------------------------------------------------%
% PACOTES DE CODIFICAÇÃO DE FONTES                                                  %
%-----------------------------------------------------------------------------------%
\usepackage[utf8]{inputenc} % Permite o uso de caracteres ISO 8859-1, incluindo os
%                               caracteres acentuados diretamente.
\usepackage[T1]{fontenc} % Uso de fontes T1, necessário para tratar caracteres
%                          acentuados como um único bloco.

%-----------------------------------------------------------------------------------%
% PACOTES DE LÍNGUAS                                                                %
%-----------------------------------------------------------------------------------%
\usepackage[french]{babel} % Seleciona a língua do documento, definindo nomes de
%                              seções, nome do índice, da bibliografia, etc. Em caso
%                              de documento com mais de uma língua, a padrão é a
%                              última.
\NoAutoSpaceBeforeFDP % Utilizar em francês se quiser evitar espaços antes de :

%-----------------------------------------------------------------------------------%
% PACOTES DE BIBLIOGRAFIA                                                           %
%-----------------------------------------------------------------------------------%
%\usepackage{babelbib} % Permite definir a língua das entradas da bibliografia. Usar
%                       [fixlanguage] para uma mesma língua para todas as entradas e
%                       \selectbiblanguage{} para definir a língua. Um estilo compa-
%                       tível com babelbib deve ser usado (ex: babplain)
\usepackage{cite} % Organiza os elementos citados dentro de um mesmo \cite.

%-----------------------------------------------------------------------------------%
% PACOTES DE FONTES                                                                 %
%-----------------------------------------------------------------------------------%
% Computer Modern (fonte padrão)                                                    %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage{ae} % A usar com a fonte padrão do LaTeX quando forem gerados PDFs, para
%                 corrigir erros de visualização

% Computer Modern Bright (sans serif)                                               %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage{cmbright}

% Times New Roman                                                                   %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage{mathptmx} % Muda texto e modo matemático
%\usepackage{times} % Apenas texto, não muda modo matemático

% Arial                                                                             %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage[scaled]{uarial} % Arial como fonte sans serif padrão

% Palatino                                                                          %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage{mathpazo} % Muda texto e modo matemático
%\usepackage{palatino} % Apenas texto, não muda modo matemático

% Concrete                                                                          %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage{ccfonts} % Texto: Concrete; Matemático: Concrete Math
%\usepackage{ccfonts, eulervm} % Texto: Concrete; Matemático: Euler

% Iwona                                                                             %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage[math]{iwona} % Texto e modo matemático: Iwona

% Kurier                                                                            %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage[math]{kurier} % Texto e modo matemático: Kurier

% Antykwa Póltawskiego                                                              %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
%\usepackage{antpolt} % Texto: Antykwa Póltawskiego; Matemático: nenhum
                     % Usar fontenc = QX ou OT4

% Utopia                                                                            %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %                     
%\usepackage{fourier} % Texto: Utopia; Matemático: Fourier

% KP Serif                                                                          %
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - %
\usepackage{kpfonts}

%-----------------------------------------------------------------------------------%
% CORES                                                                             %
%-----------------------------------------------------------------------------------%
\usepackage{color}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkmagenta}{rgb}{0.5,0,0.5}
\definecolor{darkgray}{rgb}{0.5,0.5,0.5}
\definecolor{darkblue}{rgb}{0.2,0.2,0.4}
\definecolor{darkred}{rgb}{0.6,0.15,0.15}
\definecolor{gray}{rgb}{0.65,0.65,0.65}
\definecolor{lightgray}{rgb}{0.8,0.8,0.8}
\definecolor{lightblue}{rgb}{0.5,0.5,1}
\definecolor{lightgreen}{rgb}{0.5,1,0.5}
\definecolor{deadred}{rgb}{0.7, 0.2, 0.2}
\definecolor{deadblue}{rgb}{0.2, 0.2, 0.7}

%-----------------------------------------------------------------------------------%
% PACOTES DIVERSOS                                                                  %
%-----------------------------------------------------------------------------------%
\usepackage{icomma} % Permite uso de vírgula como separador decimal
\usepackage{url} % Pacote para não ter problemas com URLs. Usar \url{}
%\usepackage{randtext} % Troca a ordem de letras de uma frase (útil com e-mails em
                      % PDFs a serem publicados on-line.
\usepackage[hidelinks]{hyperref}
%\usepackage{showkeys} % Para mostrar o nome dos labels
\usepackage{enumitem} % Facilita o uso de listas, inclusive referências a itens de
                      % listas.
%\usepackage[absolute]{textpos} % Posição absoluta de texto na página
%\usepackage{pdfpages} % Permite incluir documentos em PDF no arquivo
%\usepackage{refcheck} % Verifica as referências procurando por
%                      % labels não usados ou equações numeradas sem labels.
%                      % Verificar o arquivo .log e procurar por RefCheck.
%\usepackage[french]{algorithm2e}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONFIGURAÇÕES                                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-----------------------------------------------------------------------------------%
% FORMATAÇÃO DO TEXTO                                                               %
%-----------------------------------------------------------------------------------%
%\onehalfspacing % Espaçamento 1 1/2 (definido no pacote setspace)

%-----------------------------------------------------------------------------------%
% DEFINIÇÃO DE AMBIENTES MATEMÁTICOS                                                %
%-----------------------------------------------------------------------------------%
%\theoremstyle{plain}
%\newtheorem{theo}{Teorema}[section]
%\newtheorem{lemm}[theo]{Lema}
%\newtheorem{coro}[theo]{Corolário}
%\newtheorem{prop}[theo]{Proposição}
%\theoremstyle{definition}
%\newtheorem{defi}[theo]{Definição}
%\newtheorem{remq}[theo]{Observação}
%%\newtheorem{expl}[theo]{Exemplo}
%\newenvironment{expl}%
%  {\refstepcounter{theo}%
%    \begin{list}{}{%
%    \setlength{\topsep}{0pt}%
%    \setlength{\leftmargin}{\parindent}%
%    \setlength{\rightmargin}{0pt}%
%    \setlength{\listparindent}{\parindent}%
%    \setlength{\itemindent}{0pt}%
%    \setlength{\parsep}{\parskip}}%
%    \item[]{\bf Exemplo \thetheo. }}%
%  {\hspace*{\fill} $\square$ \end{list} \medskip}
%\newenvironment{solu}%
%  {\noindent {\bf Solução. }\small}%
%  {\hspace*{\fill} $\square$ \normalsize \medskip}
%\newenvironment{dems}[1][Demonstração]%
%  {\begin{list}{}{%
%    \setlength{\topsep}{0pt}%
%    \setlength{\leftmargin}{\parindent}%
%    \setlength{\rightmargin}{0pt}%
%    \setlength{\listparindent}{\parindent}%
%    \setlength{\itemindent}{0pt}%
%    \setlength{\parsep}{\parskip}}%
%    \item[]{\bf #1. }}%
%  {\hspace*{\fill} $\blacksquare$ \end{list} \medskip}


%-----------------------------------------------------------------------------------%
% DEFINIÇÃO DE COMANDOS MATEMÁTICOS                                                 %
%-----------------------------------------------------------------------------------%
%\newcommand*\diff{\mathop{}\!\mathrm{d}}

%\newcommand{\norm}[1]{\left\lVert #1\right\lVert} % Norma
%\newcommand{\abs}[1]{\left\lvert #1\right \rvert} % Valor absoluto
%\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor} % Arredondar para baixo
%\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil} % Arredondar para cima


%-----------------------------------------------------------------------------------%
% NUMERAÇÃO DE ELEMENTOS                                                            %
%-----------------------------------------------------------------------------------%
%\numberwithin{table}{section}
%\numberwithin{table}{subsection}
%\numberwithin{figure}{section}
%\numberwithin{figure}{subsection}
\numberwithin{equation}{section}
%\numberwithin{equation}{subsection}
%\numberwithin{theo}{chapter}
%\numberwithin{theo}{subsection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTRUTURA DO DOCUMENTO                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{2I006 \\ Projet : Le Robot Trieur \\ Première partie : Algorithme ``au plus proche''}
\author{Ariana Carnielli et Lisa Kacel}
\date{}

\maketitle

\section{Introduction}

Ce projet s'intéresse à la recherche automatique des solutions pour le jeu du ``robot trieur''. Dans ce jeu, un robot se déplace dans un grille à $m$ lignes et $n$ colonnes. Chaque case possède une couleur de fond et peut comporter une pièce colorée, le nombre de cases et pièces d'une même couleur étant identique. Le robot peut porter au plus une pièce, il peut se déplacer d'une case à toutes les cases voisines, et peut échanger la pièce qu'il porte contre la pièce dans la case où il est, prendre la pièce de la case où il est s'il ne porte pas déjà une pièce, ou laisser la pièce qu'il porte dans la case où il est si celle-ci n'a pas déjà une pièce. L'objectif du jeu est de ranger chaque pièce dans une case de même couleur. Une case comportant une pièce de même couleur que son fond est appelée \emph{noire}.

L'implémentation du jeu a été fournie pour ce projet. L'objectif de cette première partie du projet est de donner quelques implémentations différentes d'un algorithme pour résoudre le problème, appelé algorithme ``au plus proche'', et comparer leurs complexités et vitesses d'exécution.

L'algorithme ``au plus proche'' consiste à, tant qu'il reste une case non-noire, vérifier si le robot porte une pièce ou pas. S'il porte une pièce, le robot se déplace à la case la plus proche avec la même couleur de fond que la pièce et la dépose. Sinon, il cherche la plus proche case non-noire avec une pièce et se déplace pour la prendre. En cas d'égalité de distance, la priorité est donnée à la case en haut, à gauche. Les implémentations différent par la méthode utilisée pour trouver la case la plus proche où se déplacer.

Il est intéressant à noter que cet algorithme ne donne pas forcément la solution avec le nombre minimal de déplacements. En effet, considérons l'exemple de la grille de la Figure \ref{FigExpl}. On note les déplacements du robot vers le haut, le bas, la gauche et la droite respectivement par \texttt{U}, \texttt{D}, \texttt{L} et \texttt{R}, et l'échange de pièce du robot par \texttt{S}. Si le robot se trouve initialement à la case en haut à gauche, une application de l'algorithme ``au plus proche'' donne la solution suivante, à 10 déplacements :

\texttt{S R S L S R R S R S D S L S L S U R S}

Néanmoins, une autre solution possible, à 7 déplacements, est :

\texttt{S R R S R S D S L S L S U S}

On remarque par cet exemple que chercher à chaque fois la case la plus proche avec la même couleur peut ne pas donner la solution optimale.

\begin{figure}[ht]
\centering
\begin{tikzpicture}
\fill[black] (0, 0) -- (2, 0) -- (2, 2) -- (0, 2);
\fill[violet] (2, 0) -- (4, 0) -- (4, 2) -- (2, 2);
\fill[red!50!yellow] (4, 0) -- (6, 0) -- (6, 2) -- (4, 2);
\fill[green] (6, 0) -- (8, 0) -- (8, 2) -- (6, 2);
\fill[blue] (0, 2) -- (2, 2) -- (2, 4) -- (0, 4);
\fill[yellow] (2, 2) -- (4, 2) -- (4, 4) -- (2, 4);
\fill[yellow] (4, 2) -- (6, 2) -- (6, 4) -- (4, 4);
\fill[red] (6, 2) -- (8, 2) -- (8, 4) -- (6, 4);

\fill[yellow] (2.5, 0.5) -- (3.5, 0.5) -- (3.5, 1.5) -- (2.5, 1.5);
\fill[violet] (4.5, 0.5) -- (5.5, 0.5) -- (5.5, 1.5) -- (4.5, 1.5);
\fill[red!50!yellow] (6.5, 0.5) -- (7.5, 0.5) -- (7.5, 1.5) -- (6.5, 1.5);
\fill[yellow] (0.5, 2.5) -- (1.5, 2.5) -- (1.5, 3.5) -- (0.5, 3.5);
\fill[blue] (2.5, 2.5) -- (3.5, 2.5) -- (3.5, 3.5) -- (2.5, 3.5);
\fill[red] (4.5, 2.5) -- (5.5, 2.5) -- (5.5, 3.5) -- (4.5, 3.5);
\fill[green] (6.5, 2.5) -- (7.5, 2.5) -- (7.5, 3.5) -- (6.5, 3.5);
\end{tikzpicture}
\caption{Exemple de grille où l'algorithme ``au plus proche'' ne donne pas le nombre minimal de déplacements.}
\label{FigExpl}
\end{figure}

\section{Version naïve}

La première méthode utilisée pour chercher la case la plus proche est celle dite \emph{naïve}, qui consiste à parcourir, à chaque fois, toute la grille du jeu à partir de la case $(0, 0)$ afin de trouver la case la plus proche à la case où le robot se trouve. On a pour cela implémenté plusieurs fonctions utiles dans une bibliothèque de fonctions : la fonction \verb@PlusCourtChemin@ de la Question 1.2 et des petites fonctions qui aident à rendre le code plus lisible. La plupart d'entre elles retourne des booléens utilisés pour décider où le robot va se déplacer. En particulier, on a implémenté des fonctions répondant à la Question 1.3.

On a implémenté deux fonctions \verb@RechercheCaseNaif_c@ et \verb@RechercheCaseNaif_nn@ qui retournent les coordonnées $(k, l)$, respectivement, de la case la plus proche d'une case $(i, j)$ donnée et dont la couleur de fond est une couleur $c$ donnée, et de la case la plus proche de $(i, j)$ non-noire et comportant une pièce. On a utilisé ces deux fonctions et les fonctions données pour implémenter une résolution par l'algorithme ``au plus proche''. On a aussi crée un programme principal \verb@Solveur@ qui prend en argument les dimensions de la grille, le nombre de couleurs, la graine pour le générateur aléatoire et le numéro du solveur à utiliser (1 pour le solveur naïf, d'autres numéros ayant été ajoutés pour les solveurs implémentés dans les sections suivantes) et qui enregistre la solution trouvée dans un fichier.

Expérimentalement, en utilisant la fonction \verb@clock@ de la bibliothèque \verb@time.h@, on a trouvé les temps d'exécution de la Table \ref{TempsNaive}. Le nombre de couleurs a été choisi comme étant approximativement égal à $0,1\%$ du nombre total de cases de la grille et la simulation a été répétée 4 fois pour chaque dimension de la grille, le temps donné dans le tableau étant le temps moyen. On remarque que le temps moyen d'exécution dépasse les $30 s$ pour des grilles de taille entre $260 \times 260$ et $270 \times 270$.

\begin{table}[ht]
\centering
\begin{tabular}{ccc}
\hline\hline
Dimensions de la grille & Nombre de couleurs & Temps moyen d'exécution \tabularnewline
\hline
$250 \times 250$ & $63$ & $22,94 s$ \tabularnewline
$260 \times 260$ & $68$ & $29,29 s$ \tabularnewline
$270 \times 270$ & $73$ & $31,36 s$ \tabularnewline
\hline\hline
\end{tabular}
\caption{Temps d'exécution de la version naïve.}
\label{TempsNaive}
\end{table}

\section{Version circulaire}

La méthode circulaire de recherche de la case $(k, l)$ la plus proche d'une case $(i, j)$ donnée consiste à démarrer la recherche depuis $(i, j)$ et chercher de façon circulaire, en augmentant la distance de $1$ à chaque fois jusqu'à ce qu'une case avec la propriété voulue soit trouvée. Par rapport à la version naïve, l'avantage est que l'on peut arrêter la recherche dès qu'une première case est trouvée, sans avoir besoin de parcourir toute la grille.

On a implémenté les deux fonctions \verb@RechercheCaseCirculaire_c@ et \verb@Recherche@\allowbreak\verb@CaseCirculaire_nn@, analogues à celles implémentées pour la version naïve, et un solveur les utilisant. Les résultats expérimentaux de temps moyens d'exécution sur 4 simulations sont données dans la Table \ref{TempsCirculaire}, qui les compare avec les résultats de la Table \ref{TempsNaive}. Comme pour la méthode naïve, le nombre de couleurs a été choisi comme étant approximativement égal à $0,1\%$ du nombre total de cases de la grille et la moyenne de temps est faite sur 4 simulations. On remarque que le temps d'exécution moyen de la version circulaire est plus petit, car la recherche s'arrête dès qu'une case a été trouvée. On peut donc résoudre des grilles de dimension jusqu'à environ $310 \times 310$ en moins de $30 s$.

\begin{table}[ht]
\centering
\begin{tabular}{>{\centering} m{0.2\textwidth} >{\centering} m{0.2\textwidth} >{\centering} m{0.2\textwidth} >{\centering} m{0.2\textwidth}}
\hline\hline
Dimensions de la grille & Nombre de couleurs & Temps moyen d'exécution, version naïve & Temps moyen d'exécution, version circulaire \tabularnewline
\hline
$250 \times 250$ &  $63$ & $22,94 s$ & $12,38 s$ \tabularnewline
$260 \times 260$ &  $68$ & $29,29 s$ & $13,61 s$ \tabularnewline
$270 \times 270$ &  $73$ & $31,36 s$ & $17,34 s$ \tabularnewline
$300 \times 300$ &  $90$ &           & $26,89 s$ \tabularnewline
$310 \times 310$ &  $96$ &           & $29,78 s$ \tabularnewline
$320 \times 320$ & $102$ &           & $32,30 s$ \tabularnewline
\hline\hline
\end{tabular}
\caption{Temps d'exécution des versions naïve et circulaire.}
\label{TempsCirculaire}
\end{table}

On a fait des tests en augmentant le nombre de couleurs pour une taille fixé de la grille. On observe que, comme attendu, le temps d'exécution de la méthode naïve reste constant, car il parcourt toujours toutes les cases de la grille pour une recherche. Néanmoins, le temps d'exécution de la méthode circulaire augmente, car, avec plus de couleurs, il lui faut en moyenne chercher plus loin pour trouver une case.

Pour la complexité de la méthode naïve dans le cas d'une grille $n \times n$, la recherche parcourt toujours toutes les $n^2$ cases de la grille, et est ainsi effectuée en $\Theta(n^2)$. Pour résoudre la grille, il faut effectuer cette recherche une fois pour chaque pièce de la grille, soit $n^2$ pièces, donc la complexité est en $\Theta(n^4)$.

Pour la méthode circulaire, le pire cas correspond à lorsque la case recherchée est le plus éloignée possible de la case courante, auquel cas il faut parcourir toutes les $n^2$ cases de la grille, mais elle peut être plus courte, lorsque par exemple la case recherchée est voisine de la case courante. On a donc une complexité de $O(n^2)$. Comme pour la méthode naïve, il faut effectuer la recherche une fois pour chacune des $n^2$ pièces, donnant donc une complexité en $O(n^4)$.

Les expérimentations permettent de retrouver cette évaluation de la complexité. Pour la méthode naïve, en utilisant la première et la troisième lignes du tableau, on obtient $\frac{31,36 s}{22,94 s} \approx 1,37$ et $\left(\frac{270}{250}\right)^4 \approx 1,36$, ce qui valide la complexité en $\Theta(n^4)$. De même, pour la méthode circulaire, en utilisant la première et la dernière lignes du tableau, on obtient $\frac{32,30 s}{12,38 s} \approx 2,61$ et $\left(\frac{320}{250}\right)^4 \approx 2,68$, ce qui valide également le calcul théorique de la complexité en $O(n^4)$.

\section{Version par couleur}

La méthode par couleur consiste à créer un tableau de dimension 1 et longueur égale à la quantité de couleurs et contenant dans chaque case une liste doublement chainée avec les indices des cases ayant une même couleur de fond. Pour effectuer la recherche de la case la plus proche d'une couleur donnée, il suffit de parcourir la liste chainée correspondante. On ne fait donc un parcours complet de la grille qu'une seule fois, pour la construction du tableau de listes. Néanmoins, on utilise encore la méthode circulaire pour trouver une case non-noire contenant une pièce.

On a commencé par implémenter une bibliothèque de fonctions pour la manipulation de listes chainées, avec des fonctions d'initialisation, insertion en queue en $\Theta(1)$, suppression en $\Theta(1)$, affichage, etc. Ensuite, on a implémenté la fonction \verb@LDC@\allowbreak\verb@rechercherPlusProcheCase@ de recherche de case plus proche d'une case $(i, j)$ passée en argument. Cette fonction parcourt toute la liste chainée passée en argument pour trouver la case la plus proche.

En utilisant cette fonction et la fonction \verb@Recherche@\allowbreak\verb@CaseCirculaire_nn@ de la partie précédente, on a implémenté un nouveau solveur pour résoudre le robot trieur. Les résultats expérimentaux des temps moyen d'exécution sont donnés dans la Table \ref{TempsCouleurProp1}.

\begin{table}[ht]
\centering
\begin{tabular}{>{\centering} m{0.17\textwidth} >{\centering} m{0.17\textwidth} >{\centering} m{0.17\textwidth} >{\centering} m{0.17\textwidth} >{\centering} m{0.17\textwidth}}
\hline\hline
Dimensions de la grille & Nombre de couleurs & Temps moyen, version naïve & Temps moyen, version circulaire & Temps moyen, version par couleur \tabularnewline
\hline
$250 \times 250$ &  $63$ & $22,94 s$ & $12,38 s$ & $0,9188 s$ \tabularnewline
$260 \times 260$ &  $68$ & $29,29 s$ & $13,61 s$ & $1,052 s$  \tabularnewline
$270 \times 270$ &  $73$ & $31,36 s$ & $17,34 s$ & $1,159 s$  \tabularnewline
$300 \times 300$ &  $90$ &           & $26,89 s$ & $1,564 s$  \tabularnewline
$310 \times 310$ &  $96$ &           & $29,78 s$ & $1,761 s$  \tabularnewline
$320 \times 320$ & $102$ &           & $32,30 s$ & $1,905 s$  \tabularnewline
\hline\hline
\end{tabular}
\caption{Temps d'exécution des versions naïve, circulaire et par couleur.}
\label{TempsCouleurProp1}
\end{table}

On remarque que le temps d'exécution moyen est beaucoup plus petit que pour les deux autres versions. Pour les résultats donnés dans la suite, on a modifié légèrement le code pour ne pas sauvegarder la solution car la structure utilisée pour la sauvegarde devient vite trop grande pour la mémoire de l'ordinateur, rendant difficile la simulation des grilles de dimension de l'ordre de $1000 \times 1000$ ou supérieure. Sans la sauvegarde, le temps moyen d'exécution de la version par couleur est divisé par environ 4.

La Table \ref{TempsCouleurProp2} donne les temps moyen d'exécution pour des grandes tailles de grille, avec un nombre de couleurs correspondant toujours à $0,1\%$ du nombre de cases de la grille. Le temps d'exécution sera donc d'ordre de $30 s$ pour des grilles de taille entre $2500 \times 2500$ et $2600 \times 2600$.

\begin{table}[ht]
\centering
\begin{tabular}{>{\centering} m{0.3\textwidth} >{\centering} m{0.3\textwidth} >{\centering} m{0.3\textwidth}}
\hline\hline
Dimensions de la grille & Nombre de couleurs & Temps moyen, version par couleur \tabularnewline
\hline
$2000 \times 2000$ & $4000$ & $20,18 s$ \tabularnewline
$2500 \times 2500$ & $6250$ & $29,09 s$ \tabularnewline
$2600 \times 2600$ & $6760$ & $31,15 s$ \tabularnewline
\hline\hline
\end{tabular}
\caption{Temps d'exécution de la version par couleur sans sauvegarde de la solution.}
\label{TempsCouleurProp2}
\end{table}

On a également testé le temps moyen d'exécution avec une quantité fixe de $10$ couleurs, sans changer son nombre en fonction du nombre de cases de la grille. Dans ce cas, le temps d'exécution observé est beaucoup plus grand, comme montre la Table \ref{TempsCouleurCst}. Avec $10$ couleurs, le temps d'exécution est de l'ordre de $30 s$ pour des grilles de taille d'environ $590 \times 590$.

\begin{table}[ht]
\centering
\begin{tabular}{>{\centering} m{0.3\textwidth} >{\centering} m{0.3\textwidth} >{\centering} m{0.3\textwidth}}
\hline\hline
Dimensions de la grille & Nombre de couleurs & Temps moyen, version par couleur \tabularnewline
\hline
$580 \times 580$ & $10$ & $28,71 s$ \tabularnewline
$590 \times 590$ & $10$ & $30,48 s$ \tabularnewline
$600 \times 600$ & $10$ & $33,04 s$ \tabularnewline
\hline\hline
\end{tabular}
\caption{Temps d'exécution de la version par couleur sans sauvegarde de la solution.}
\label{TempsCouleurCst}
\end{table}

Pour expliquer cette divergence entre les Tables \ref{TempsCouleurProp2} et \ref{TempsCouleurCst}, on étudie la complexité théorique de cette méthode. Pour initialiser le tableau de listes chainées, il faut parcourir la grille une fois, la complexité de cette étape étant donc en $\Theta(n^2)$. Pour rechercher la case la plus proche de couleur $c$, il faut parcourir une fois la liste chainée de la couleur correspondante, et alors la complexité est $\Theta(\ell_c)$, où $\ell_c$ est la longueur de cette liste. Avec le paramètre $\alpha$ qui donne le nombre maximal de pièces d'une même couleur, et donc la taille de la plus grande liste, on obtient ainsi une complexité en $O(\alpha)$ pour la recherche. Comme il faut répéter la recherche pour les $n^2$ pièces, en prenant en compte aussi l'initialisation, la complexité totale est en $\Theta(n^2) + O(n^2 \alpha) = O(n^2 \alpha)$.

Dans le cas où l'on augmente le nombre de couleurs de façon proportionnelle à la quantité totale de cases, on a un nombre de couleurs de $c n^2$ ($c = 0,1\%$ dans les simulations ci-dessus). La longueur moyenne d'une liste chainée sera donc $\frac{n^2}{c n^2} = \frac{1}{c}$. On s'attend donc à une plus grande liste de taille de l'ordre $\frac{1}{c}$, qui est indépendant de $n$. Donc, dans ce cas, la complexité totale sera en $O(n^2)$. Dans le cas où le nombre de couleurs est fixe et égal à $c$, $\alpha$ sera de l'ordre de $\frac{n^2}{c}$, alors la complexité totale sera en $O(n^4)$. Cela explique donc pourquoi le cas avec nombre de couleurs proportionnel au nombre de cases est beaucoup plus rapide.

\section{Version par AVL}

Dans la méthode par AVL, on utilise des arbres binaires de recherche équilibrées du type AVL pour faciliter la recherche de la case la plus proche avec une couleur donnée. Plus précisément, on crée un tableau \verb@M@ d'arbres AVL de dimension \verb@m@ $\times$ \verb@nb_coul@, où \verb@m@ est le nombre de lignes de la grille et \verb@nb_coul@ le nombre de couleurs utilisées dans la grille. L'arbre \verb@M[i][c]@ contient les indices de colonne \verb@j@ de toutes les cases de la grille dans la ligne \verb@i@ et de couleur de fond \verb@c@.

On a commencé par l'implémentation d'une bibliothèque pour la manipulation d'arbres AVL, avec des fonctions d'initialisation, insertion en $O(\log(\beta))$ (où $\beta$ est la quantité d'éléments de l'arbre), suppression en $O(\log(\beta))$, rotations droite et gauche en $O(1)$, équilibrage d'un n\oe{}ud en $O(1)$, affichage, etc. Les fonctions de cette bibliothèque ont été testées en insérant, recherchant et supprimant plusieurs éléments d'un arbre.

On a également implémenté une fonction de recherche qui, étant donné un arbre AVL à entrées positives ou nulles et un entier $c$, recherche et retourne l'entier le plus proche de $c$ dans l'arbre (ou $-1$ si l'arbre est vide). Dans le cas où deux entiers de l'arbre sont à même distance de $c$, on retourne le plus petit. Cette fonction utilise une recherche dichotomique : si la valeur $c$ est plus petite que la racine de l'arbre, alors l'élément de l'arbre le plus proche de $c$ est soit sa racine, soit un élément de son sous-arbre gauche, avec la situation symétrique lorsque $c$ est plus grand que la racine de l'arbre. Une implémentation récursive de cette fonction de recherche permet ainsi d'avoir une complexité en $O(h)$, où $h$ est la hauteur de l'arbre, et donc en $O(\log(\beta))$ puisqu'un arbre AVL est équilibré.

Pour utiliser cette structure dans l'implémentation de l'algorithme ``au plus proche'', on a écrit une fonction de création du tableau d'arbres AVL \verb@M@ à partir d'une grille. Cette fonction parcourt toute la grille en insérant, pour les cases non-noires, son indice de colonne dans l'arbre correspondant à sa couleur de fond. On a aussi décidé de rajouter une dernière colonne à \verb@M@ contenant, pour chaque ligne, un arbre avec les indices de toutes les cases non-noires avec une pièce de la ligne, afin de pouvoir implémenter efficacement la recherche de cases non-noires.

On a en plus implémenté des fonctions de recherche de case par couleur et de recherche de cases non-noires avec une pièce afin d'implémenter l'algorithme ``au plus proche'' par AVL. Pour les recherches de la case la plus proche, on parcourt les lignes du tableau \verb@M@ et, pour chaque ligne, on recherche la colonne la plus proche dans l'arbre AVL de la couleur correspondante, gardant à la fin la distance minimale par rapport à toutes les lignes.

Le test du temps moyen d'exécution avec une quantité de couleurs égal à $0,1\%$ du nombre d'éléments de la grille et avec la quantité fixe de $10$ couleurs est donné dans la Table \ref{TempsAVL}.

\begin{table}
\centering
\begin{tabular}{>{\centering} m{0.3\textwidth} >{\centering} m{0.3\textwidth} >{\centering} m{0.3\textwidth}}
\hline\hline
Dimensions de la grille & Nombre de couleurs & Temps moyen, version par AVL \tabularnewline
\hline
$1000 \times 1000$ & $1000$ & $24,47 s$ \tabularnewline
$1050 \times 1050$ & $1103$ & $28,39 s$ \tabularnewline
$1100 \times 1100$ & $1210$ & $33,11 s$ \tabularnewline
\hline
$1000 \times 1000$ & $10$ & $26,95 s$ \tabularnewline
$1050 \times 1050$ & $10$ & $32,41 s$ \tabularnewline
$1100 \times 1100$ & $10$ & $38,50 s$ \tabularnewline
\hline\hline
\end{tabular}
\caption{Temps d'exécution de la version par AVL sans sauvegarde de la solution.}
\label{TempsAVL}
\end{table}

En comparant avec la méthode par couleur, dont les résultats sont dans les Tables \ref{TempsCouleurProp2} et \ref{TempsCouleurCst}, on remarque que, avec une quantité de couleurs égale à environ $0,1\%$ de la quantité de cases de la grille, la dimension de la grille qui donne un temps moyen d'exécution de $30 s$ est entre $1050 \times 1050$ et $1100 \times 1100$ pour la méthode par AVL, ce qui est plus petit que la dimension correspondante pour la méthode par couleur et indique donc un temps d'exécution plus important. Avec un nombre fixe de $10$ couleurs, la dimension de la grille qui donne un temps moyen d'exécution de $30 s$ est entre $1000 \times 1000$ et $1050 \times 1050$ pour la méthode par AVL, plus grand que la dimension correspondante pour la méthode par couleur, ce qui indique un temps d'exécution plus rapide. On remarque également que le temps d'exécution décroit un peu lorsque le nombre de couleurs augmente pour une même dimension de la grille.

La complexité de la création du tableau d'AVL est en $O(n^2 \log(\beta))$, où $\beta$ est le nom\-bre maximal d'éléments dans un arbre AVL du tableau. En effet, il faut parcourir les $n^2$ éléments de la grille et les insérer dans un AVL, l'insertion étant faite, comme vu précédemment, en $O(\log(\beta))$. La complexité de la recherche de la case la plus proche par AVL est en $O(n \log(\beta))$. En effet, on fait une boucle sur les $n$ lignes du tableau \verb@M@ et, pour chaque ligne, on fait une recherche uniquement sur l'arbre de la couleur correspondante, qui, comme vu précédemment, se fait en $O(\log(\beta))$. Comme cette recherche est répétée pour les $n^2$ pièces de la grille, on a une complexité totale en $O(n^2 \log(\beta)) + O(n^3 \log(\beta)) = O(n^3 \log(\beta))$.

Dans le cas où la quantité de couleurs est proportionnelle au nombre de cases de la grille et vaut $c n^2$, le nombre moyen de cases d'une même couleur dans une ligne est $\frac{n}{c n^2} = \frac{1}{c n}$, et ainsi la complexité totale de la méthode par AVL est en $O(n^3 \log(1/n)) = O(n^3)$. Cette complexité est supérieure à celle de la version par couleur, ce qui explique pourquoi les $30 s$ d'exécution sont obtenues pour des dimensions de la grille plus petites que dans la version par couleur.

Dans le cas où la quantité de couleurs est constante et vaut $c$, le nombre moyen de cases d'une même couleur dans une ligne est $\frac{n}{c}$, ce qui donne une complexité totale en $O(n^3 \log(n))$ pour la méthode par AVL. Cette complexité est maintenant inférieure à celle de la version par couleur, ce qui explique pourquoi les $30 s$ d'exécution sont obtenues pour des dimensions de la grille plus grandes que dans la version par couleur.

\end{document}
